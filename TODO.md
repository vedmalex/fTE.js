function Template Engine for javascript node.js inspired by [nJSt][https://github.com/unclechu/node-njst] and [ect][https://github.com/baryshev/ect]

It little bit modular, with little bit extensible `PEG.js`, little bit... unusual... without comparising it with any other template engine.

I use if for as code-generator.
it can generete your template into pure javascript for you to optimize. 

It is from the groud using [PEG.js][https://github.com/dmajda/pegjs]

It comes with Sublime-Text-2 syntax hightlight see `./sublime-text/` folder.

list of TODO:

- manual
- examples


### Links

[PEG.js project][http://pegjs.majda.cz/online]
[PEG.js online editor][http://peg.arcanis.fr/]

using esprima instead of acorn.

TODO:
 - изменять context переменную...
 - асинхронные вызовы, 
  - на промисах
  - на callback
  !{} escape --> done
  !!!indentation!!!
 unescape // стандартные функции
 - добавить комментарии, с параметрами для однострочных и блочных комментариев.
 - stream-support??? что это...

в блок надо передавать переменные... хотя функции справляются и без блока

зачин для резки файлов есть directive fileName

-#> убирает все пробелы включая ближайший перенос строки.

<#- убирает все пробелы перед собой до следующей строки

все директивы по умолчанию убирают за собой строки..

все requireAs действуют только в рамках одного текущего шаблона, вне зависимости от наследования

1. Шаблонизатор должен использовать уже скомпилированные шаблоны для своей работы, чтобы не использовать fte.peg.js, а вместо него использовать только raw.peg.js поскольку его кодогенерацию можно легко кастомизировать.

2. специальный режим компиляции шаблонов сервисных шаблонов...
когда одни генеряться с нуля? нужен или нет? если будет стартовый шаблон, то не нужен...

NODE!: to be able debug template, that is generated pass to Factory debug:true, this will inculde the tempalte using general require function, otherwise it will load throught saveEval function.

выдавать ошибку если в стеке скриптов остальня один... значит один из шаблонов не знает что от него будут наследовать, и не содержит конструкции content

минифицировать шаблоны.... через gulp

directives:

@ context obj

трасировка ошибок в консоль ... 
- защита шаблона...
- скомпилировать шаблоны и вырезать стандартный метод для fte загрузки шаблона так чтобы не поддерживать две схемы... и забыть оставить


blocks теперь принимают параметры.!!!!
blocks могут использовать директивы,
 <#@ context 'name' #>


нужны ли блоку директивы ... например context name?

noIndent - macro директива убирает Код отвечающий за Indentation
и по умолчанию не обрабатывает код на Indent

добавить в подсветку синтаксиса код для
Принимать функцию в качестве шаблона, а не просто модуль....

доделать.

параметры: мониторить директорию...
убрать require на debug... сейчас все работает нормально.


код


посмотреть как можно использовать immutable js для всего что нам нужно, в частности можно использовать memoization... как я и подумал... Кришна!!!
Immutable js

Подумать над:
alias для теплейта
globalAlias

доделать код для примера.

параметр расширение по-умолчанию... 

добавить информацию об обновлении файла... когда он передается по абсолютному пути...
чтобы проверить, а вдруг он изменился...

или поставить список обработчиков, которые будут сбрасывать флажки по изменению шаблона...

перенести функцию из примера в API и добавить в документацию

express передает шаблонизатору кучу параметров... их можно научиться обрабатывать
там в том числе есть и шаблон, и путь откуда взят, и параметр кэшировать или нет результаты компиляции шаблона....

использовать webpack для нарезки файлов.... 

при кэшировании ,сбрасывать и все зависимые и зависящие файлы из кэша ...

Убрал возможность в шаблоне requireAs делать по асболютному пути... не безопасно.

Просто как идея.... 
NPHP - node precompiled html pages... директории с шаблонами лежат, 
но в них не только отображение контента, но и код по его получению и прочее.
для этого нужно научить fte Работать с promise и вообще с асинхронным режимом.

для этого нужно передать управление маршрутизацией в третий модуль, чтобы он по роуту искал шаблон и запускал его... в общем как-то так.

была так же идея pipeline.js реанимировать, переписать на promise-ах async/await

directive:
  callback
  promise
  generator
  async

Проверить возможность передачи в функцию для шаблонизации тех же параметров что и в обычный модуль
 require и прочеее...

ИСПОЛЬЗУЕМ node v6

pipeline.js на await/ и транзакции на нем же.... сделать.

пример подгрузки функции лежит в template-benchmark


Async не совсем понятно нужен или нет. ... и как должен выглядеть код

не понятно как его можно будет использовать.... пока задач нет.
но есть блоки которые должны сгенерить файлы...
в этом случае результат работы шаблона будет не строка, а хэш поименованный названиями файлов, которые нужно созадть.

т.е. нужно предусмотреть возможность формирования не просто строки, но сложно объекта...
это можно сделать группой шаблонов, с подготовленными данными... что тоже не плохо
может быть не стоит мешать код шаблонизатора с кодом...
другой момент шаблон может вернуть buffer. например картинку... что тогда делать.

файл компанйона, контроллер....

для генерации использовать виртуальную fs как у yeoman-generator
strongloop используют в своей кодогенерации yeoman для loopback

... создать strongloop проектик и посмотреть кодогенерацию.

mantra-cli в качестве примера.... и за основу генератора.


основная проблема состоит в том, что выбирая то чем мы будем пользоваться для отображения хранения данных, мы забываем об архитектуре приложения...